{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/eriki/Documents/GitHub/amplify-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { r as registerInstance, h, c as createEvent, H as Host, g as getElement } from './index-83f2275b.js';\nimport { Logger, browserOrNode, I18n } from '@aws-amplify/core';\nimport '@aws-amplify/auth';\nimport { T as Translations } from './Translations-c833f663.js';\nimport { c as NO_INTERACTIONS_MODULE_FOUND } from './constants-c8ecaa24.js';\nimport { Interactions } from '@aws-amplify/interactions'; // AudioRecorder settings\n\nconst RECORDER_EXPORT_MIME_TYPE = 'application/octet-stream';\nconst DEFAULT_EXPORT_SAMPLE_RATE = 16000;\nconst FFT_SIZE = 2048; // window size in samples for Fast Fourier Transform (FFT)\n\nconst FFT_MAX_DECIBELS = -10; // maximum power value in the scaling range for the FFT analysis data\n\nconst FFT_MIN_DECIBELS = -90; // minimum power value in the scaling range for the FFT analysis data\n\nconst FFT_SMOOTHING_TIME_CONSTANT = 0.85; // averaging constant with the last analysis frame\n\n/**\n * Merges multiple buffers into one.\n */\n\nconst mergeBuffers = (bufferArray, recLength) => {\n  const result = new Float32Array(recLength);\n  let offset = 0;\n\n  for (let i = 0; i < bufferArray.length; i++) {\n    result.set(bufferArray[i], offset);\n    offset += bufferArray[i].length;\n  }\n\n  return result;\n};\n/**\n * Downsamples audio to desired export sample rate.\n */\n\n\nconst downsampleBuffer = (buffer, recordSampleRate, exportSampleRate) => {\n  if (exportSampleRate === recordSampleRate) {\n    return buffer;\n  }\n\n  const sampleRateRatio = recordSampleRate / exportSampleRate;\n  const newLength = Math.round(buffer.length / sampleRateRatio);\n  const result = new Float32Array(newLength);\n  let offsetResult = 0;\n  let offsetBuffer = 0;\n\n  while (offsetResult < result.length) {\n    const nextOffsetBuffer = Math.round((offsetResult + 1) * sampleRateRatio);\n    let accum = 0,\n        count = 0;\n\n    for (let i = offsetBuffer; i < nextOffsetBuffer && i < buffer.length; i++) {\n      accum += buffer[i];\n      count++;\n    }\n\n    result[offsetResult] = accum / count;\n    offsetResult++;\n    offsetBuffer = nextOffsetBuffer;\n  }\n\n  return result;\n};\n/**\n * converts raw audio values to 16 bit pcm.\n */\n\n\nconst floatTo16BitPCM = (output, offset, input) => {\n  let byteOffset = offset;\n\n  for (let i = 0; i < input.length; i++, byteOffset += 2) {\n    const s = Math.max(-1, Math.min(1, input[i]));\n    output.setInt16(byteOffset, s < 0 ? s * 0x8000 : s * 0x7fff, true);\n  }\n};\n/**\n * Write given strings in big-endian order.\n */\n\n\nconst writeString = (view, offset, string) => {\n  for (let i = 0; i < string.length; i++) {\n    view.setUint8(offset + i, string.charCodeAt(i));\n  }\n};\n/**\n * Encodes raw pcm audio into a wav file.\n */\n\n\nconst encodeWAV = (samples, exportSampleRate) => {\n  /**\n   * WAV file consists of three parts: RIFF header, WAVE subchunk, and data subchunk. We precompute the size of them.\n   */\n  const audioSize = samples.length * 2; // We use 16-bit samples, so we have (2 * sampleLength) bytes.\n\n  const fmtSize = 24; // Byte size of the fmt subchunk: 24 bytes that the audio information that we'll set below.\n\n  const dataSize = 8 + audioSize; // Byte size of the data subchunk: raw sound data plus 8 bytes for the subchunk descriptions.\n\n  const totalByteSize = 12 + fmtSize + dataSize; // Byte size of the whole file, including the chunk header / descriptor.\n  // create DataView object to write byte values into\n\n  const buffer = new ArrayBuffer(totalByteSize); // buffer to write the chunk values in.\n\n  const view = new DataView(buffer);\n  /**\n   * Start writing the .wav file. We write top to bottom, so byte offset (first numeric argument) increases strictly.\n   */\n  // RIFF header\n\n  writeString(view, 0, 'RIFF'); // At offset 0, write the letters \"RIFF\"\n\n  view.setUint32(4, fmtSize + dataSize, true); // At offset 4, write the size of fmt and data chunk size combined.\n\n  writeString(view, 8, 'WAVE'); // At offset 8, write the format type \"WAVE\"\n  // fmt subchunk\n\n  writeString(view, 12, 'fmt '); //chunkdId 'fmt '\n\n  view.setUint32(16, fmtSize - 8, true); // fmt subchunk size below this value. We set 8 bytes already, so subtract 8 bytes from fmtSize.\n\n  view.setUint16(20, 1, true); // Audio format code, which is 1 for PCM.\n\n  view.setUint16(22, 1, true); // Number of audio channels. We use mono, ie 1.\n\n  view.setUint32(24, exportSampleRate, true); // Sample rate of the audio file.\n\n  view.setUint32(28, exportSampleRate * 2, true); // Data rate, or # of data bytes per second. Since each sample is 2 bytes, this is 2 * sampleRate.\n\n  view.setUint16(32, 2, true); // block align, # of bytes per sample including all channels, ie. 2 bytes.\n\n  view.setUint16(34, 16, true); // bits per sample, ie. 16 bits\n  // data subchunk\n\n  writeString(view, 36, 'data'); // write the chunkId 'data'\n\n  view.setUint32(40, audioSize, true); // Audio byte size\n\n  floatTo16BitPCM(view, 44, samples); // raw pcm values then go here.\n\n  return view;\n};\n/**\n * Given arrays of raw pcm audio, downsamples the audio to desired sample rate and encodes it to a wav audio file.\n *\n * @param recBuffer {Float32Array[]} - 2d float array containing the recorded raw audio\n * @param recLength {number} - total length of recorded audio\n * @param recordSampleRate {number} - sample rate of the recorded audio\n * @param exportSampleRate {number} - desired sample rate of the exported file\n */\n\n\nconst exportBuffer = (recBuffer, recLength, recordSampleRate, exportSampleRate) => {\n  const mergedBuffers = mergeBuffers(recBuffer, recLength);\n  const downsampledBuffer = downsampleBuffer(mergedBuffers, recordSampleRate, exportSampleRate);\n  const encodedWav = encodeWAV(downsampledBuffer, exportSampleRate);\n  const audioBlob = new Blob([encodedWav], {\n    type: RECORDER_EXPORT_MIME_TYPE\n  });\n  return audioBlob;\n};\n\nconst logger = new Logger('AudioRecorder');\n\nclass AudioRecorder {\n  constructor(options) {\n    // input mic stream is stored in a buffer\n    this.streamBuffer = [];\n    this.streamBufferLength = 0;\n    this.recording = false;\n    this.options = options;\n  }\n  /**\n   * This must be called first to enable audio context and request microphone access.\n   * Once access granted, it connects all the necessary audio nodes to the context so that it can begin recording or playing.\n   */\n\n\n  init() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      if (browserOrNode().isBrowser) {\n        window.AudioContext = window.AudioContext || window.webkitAudioContext;\n        _this.audioContext = new AudioContext();\n        yield navigator.mediaDevices.getUserMedia({\n          audio: true\n        }).then(stream => {\n          _this.audioSupported = true;\n\n          _this.setupAudioNodes(stream);\n        }).catch(() => {\n          _this.audioSupported = false;\n          return Promise.reject('Audio is not supported');\n        });\n      } else {\n        _this.audioSupported = false;\n        return Promise.reject('Audio is not supported');\n      }\n    })();\n  }\n  /**\n   * Setup audio nodes after successful `init`.\n   */\n\n\n  setupAudioNodes(stream) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        yield _this2.audioContext.resume();\n      } catch (err) {\n        logger.error(err);\n      }\n\n      const sourceNode = _this2.audioContext.createMediaStreamSource(stream);\n\n      const processorNode = _this2.audioContext.createScriptProcessor(4096, 1, 1);\n\n      processorNode.onaudioprocess = audioProcessingEvent => {\n        if (!_this2.recording) return;\n        const stream = audioProcessingEvent.inputBuffer.getChannelData(0);\n\n        _this2.streamBuffer.push(new Float32Array(stream)); // set to a copy of the stream\n\n\n        _this2.streamBufferLength += stream.length;\n\n        _this2.analyse();\n      };\n\n      const analyserNode = _this2.audioContext.createAnalyser();\n\n      analyserNode.minDecibels = FFT_MIN_DECIBELS;\n      analyserNode.maxDecibels = FFT_MAX_DECIBELS;\n      analyserNode.smoothingTimeConstant = FFT_SMOOTHING_TIME_CONSTANT;\n      sourceNode.connect(analyserNode);\n      analyserNode.connect(processorNode);\n      processorNode.connect(sourceNode.context.destination);\n      _this2.analyserNode = analyserNode;\n    })();\n  }\n  /**\n   * Start recording audio and listen for silence.\n   *\n   * @param onSilence {SilenceHandler} - called whenever silence is detected\n   * @param visualizer {Visualizer} - called with audio data on each audio process to be used for visualization.\n   */\n\n\n  startRecording(onSilence, visualizer) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this3.recording || !_this3.audioSupported) return;\n\n      _this3.onSilence = onSilence || function () {};\n\n      _this3.visualizer = visualizer || function () {};\n\n      const context = _this3.audioContext;\n\n      try {\n        yield context.resume();\n      } catch (err) {\n        logger.error(err);\n      }\n\n      _this3.start = Date.now();\n      _this3.recording = true;\n    })();\n  }\n  /**\n   * Pause recording\n   */\n\n\n  stopRecording() {\n    if (!this.audioSupported) return;\n    this.recording = false;\n  }\n  /**\n   * Pause recording and clear audio buffer\n   */\n\n\n  clear() {\n    this.stopRecording();\n    this.streamBufferLength = 0;\n    this.streamBuffer = [];\n  }\n  /**\n   * Plays given audioStream with audioContext\n   *\n   * @param buffer {Uint8Array} - audioStream to be played\n   */\n\n\n  play(buffer) {\n    if (!buffer || !this.audioSupported) return;\n    const myBlob = new Blob([buffer]);\n    return new Promise((res, rej) => {\n      const fileReader = new FileReader();\n\n      fileReader.onload = () => {\n        if (this.playbackSource) this.playbackSource.disconnect(); // disconnect previous playback source\n\n        this.playbackSource = this.audioContext.createBufferSource();\n\n        const successCallback = buf => {\n          this.playbackSource.buffer = buf;\n          this.playbackSource.connect(this.audioContext.destination);\n\n          this.playbackSource.onended = () => {\n            return res();\n          };\n\n          this.playbackSource.start(0);\n        };\n\n        const errorCallback = err => {\n          return rej(err);\n        };\n\n        this.audioContext.decodeAudioData(fileReader.result, successCallback, errorCallback);\n      };\n\n      fileReader.onerror = () => rej();\n\n      fileReader.readAsArrayBuffer(myBlob);\n    });\n  }\n  /**\n   * Stops playing audio if there's a playback source connected.\n   */\n\n\n  stop() {\n    if (this.playbackSource) {\n      this.playbackSource.stop();\n    }\n  }\n  /**\n   * Called after each audioProcess. Check for silence and give fft time domain data to visualizer.\n   */\n\n\n  analyse() {\n    if (!this.audioSupported) return;\n    const analyser = this.analyserNode;\n    analyser.fftSize = FFT_SIZE;\n    const bufferLength = analyser.fftSize;\n    const dataArray = new Uint8Array(bufferLength);\n    const amplitude = this.options.amplitude;\n    const time = this.options.time;\n    analyser.getByteTimeDomainData(dataArray);\n    this.visualizer(dataArray, bufferLength);\n\n    for (let i = 0; i < bufferLength; i++) {\n      // Normalize between -1 and 1.\n      const curr_value_time = dataArray[i] / 128 - 1.0;\n\n      if (curr_value_time > amplitude || curr_value_time < -1 * amplitude) {\n        this.start = Date.now();\n      }\n    }\n\n    const newtime = Date.now();\n    const elapsedTime = newtime - this.start;\n\n    if (elapsedTime > time) {\n      this.onSilence();\n    }\n  }\n  /**\n   * Encodes recorded buffer to a wav file and exports it to a blob.\n   *\n   * @param exportSampleRate {number} - desired sample rate of the exported buffer\n   */\n\n\n  exportWAV(exportSampleRate = DEFAULT_EXPORT_SAMPLE_RATE) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this4.audioSupported) return;\n      const recordSampleRate = _this4.audioContext.sampleRate;\n      const blob = exportBuffer(_this4.streamBuffer, _this4.streamBufferLength, recordSampleRate, exportSampleRate);\n\n      _this4.clear();\n\n      return blob;\n    })();\n  }\n\n}\n\nconst visualize = (dataArray, bufferLength, canvas) => {\n  if (!canvas) return;\n  if (!browserOrNode().isBrowser) throw new Error('Visualization is not supported on non-browsers.');\n  const {\n    width,\n    height\n  } = canvas.getBoundingClientRect(); // need to update the default canvas width and height\n\n  canvas.width = width;\n  canvas.height = height;\n  const canvasCtx = canvas.getContext('2d');\n  canvasCtx.fillStyle = 'white';\n  canvasCtx.clearRect(0, 0, width, height);\n\n  const draw = () => {\n    canvasCtx.fillRect(0, 0, width, height);\n    canvasCtx.lineWidth = 1;\n    const color = getComputedStyle(document.documentElement).getPropertyValue('--amplify-primary-color');\n    canvasCtx.strokeStyle = !color || color === '' ? '#ff9900' : color; // TODO: try separate css variable\n\n    canvasCtx.beginPath();\n    const sliceWidth = width * 1.0 / bufferLength;\n    let x = 0;\n\n    for (let i = 0; i < bufferLength || i % 3 === 0; i++) {\n      const value = dataArray[i] / 128.0;\n      const y = value * height / 2;\n\n      if (i === 0) {\n        canvasCtx.moveTo(x, y);\n      } else {\n        canvasCtx.lineTo(x, y);\n      }\n\n      x += sliceWidth;\n    }\n\n    canvasCtx.lineTo(canvas.width, canvas.height / 2);\n    canvasCtx.stroke();\n  }; // Register our draw function with requestAnimationFrame.\n\n\n  requestAnimationFrame(draw);\n};\n\nconst amplifyChatbotCss = \".bot .dot{background-color:var(--bot-dot-color)}.user .dot{background-color:var(--user-dot-color)}.dot-flashing{width:2.625rem}.dot-flashing .dot{display:inline-block;width:0.625rem;height:0.625rem;border-radius:10rem;opacity:0.65}.dot-flashing .left{-webkit-animation:dot-flashing 1s infinite alternate;animation:dot-flashing 1s infinite alternate;-webkit-animation-delay:0s;animation-delay:0s}.dot-flashing .middle{margin-left:0.375rem;margin-right:0.375rem;-webkit-animation:dot-flashing 1s infinite linear alternate;animation:dot-flashing 1s infinite linear alternate;-webkit-animation-delay:0.5s;animation-delay:0.5s}.dot-flashing .right{-webkit-animation:dot-flashing 1s infinite alternate;animation:dot-flashing 1s infinite alternate;-webkit-animation-delay:1s;animation-delay:1s}@-webkit-keyframes dot-flashing{0%{opacity:0.65}50%,100%{opacity:0.1}}@keyframes dot-flashing{0%{opacity:0.65}50%,100%{opacity:0.1}}:host{--width:28.75rem;--height:37.5rem;--header-color:var(--amplify-secondary-color);--header-size:var(--amplify-text-lg);--bot-background-color:rgb(230, 230, 230);--bot-text-color:black;--bot-dot-color:var(--bot-text-color);--user-background-color:var(--amplify-blue);--user-text-color:var(--amplify-white);--user-dot-color:var(--user-text-color)}.amplify-chatbot{display:-ms-inline-flexbox;display:inline-flex;-ms-flex-direction:column;flex-direction:column;background-color:var(--background-color);border-radius:0.375rem;-webkit-box-shadow:0.0625rem 0rem 0.25rem 0 rgba(0, 0, 0, 0.15);box-shadow:0.0625rem 0rem 0.25rem 0 rgba(0, 0, 0, 0.15);-webkit-box-sizing:border-box;box-sizing:border-box;font-family:var(--amplify-font-family);margin-bottom:1rem;width:100%;height:var(--height);max-width:var(--width)}@media (min-width: 672px){.amplify-chatbot{width:var(--width)}}.header{padding:1.25rem 0.375rem 1.25rem 0.375rem;color:var(--header-color);font-size:var(--header-size);font-weight:bold;text-align:center;word-wrap:break-word}.body{border-top:0.0625rem solid rgba(0, 0, 0, 0.05);padding:1.5rem 1rem 0 1rem;display:-ms-flexbox;display:flex;-ms-flex-positive:1;flex-grow:1;-ms-flex-direction:column;flex-direction:column;overflow:auto}.bubble{max-width:100%;padding:0.8em 1.4em;text-align:left;word-wrap:break-word;margin-bottom:0.625rem}.bot{margin-right:auto;background-color:var(--bot-background-color);color:var(--bot-text-color);border-radius:1.5rem 1.5rem 1.5rem 0}.user{margin-left:auto;background-color:var(--user-background-color);color:var(--user-text-color);border-radius:1.5rem 1.5rem 0 1.5rem}.footer{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;border-top:0.062rem solid rgba(0, 0, 0, 0.05);padding-right:0.625rem;min-height:3.125rem}.footer amplify-input{--border:none;--margin:0;-ms-flex-positive:1;flex-grow:1}canvas{margin-left:0.625rem;margin-right:0.625rem;-ms-flex-positive:1;flex-grow:1;height:3.125rem}.icon-button{--icon-height:1.25rem;--icon-fill:var(--amplify-primary-color);--padding:0.625rem;--width:auto}\"; // enum for possible bot states\n\nvar ChatState;\n\n(function (ChatState) {\n  ChatState[ChatState[\"Initial\"] = 0] = \"Initial\";\n  ChatState[ChatState[\"Listening\"] = 1] = \"Listening\";\n  ChatState[ChatState[\"SendingText\"] = 2] = \"SendingText\";\n  ChatState[ChatState[\"SendingVoice\"] = 3] = \"SendingVoice\";\n  ChatState[ChatState[\"Error\"] = 4] = \"Error\";\n})(ChatState || (ChatState = {})); // Message types\n\n\nvar MessageFrom;\n\n(function (MessageFrom) {\n  MessageFrom[\"Bot\"] = \"bot\";\n  MessageFrom[\"User\"] = \"user\";\n})(MessageFrom || (MessageFrom = {})); // Error types\n\n\nvar ChatErrorType;\n\n(function (ChatErrorType) {\n  ChatErrorType[ChatErrorType[\"Recoverable\"] = 0] = \"Recoverable\";\n  ChatErrorType[ChatErrorType[\"Unrecoverable\"] = 1] = \"Unrecoverable\";\n})(ChatErrorType || (ChatErrorType = {}));\n\nconst AmplifyChatbot = class {\n  constructor(hostRef) {\n    registerInstance(this, hostRef);\n    /** Clear messages when conversation finishes */\n\n    this.clearOnComplete = false;\n    /** Continue listening to users after they send the message */\n\n    this.conversationModeOn = false;\n    /** Text placed in the top header */\n\n    this.botTitle = Translations.CHATBOT_TITLE;\n    /** Whether voice chat is enabled */\n\n    this.voiceEnabled = false;\n    /** Whether text chat is enabled */\n\n    this.textEnabled = true;\n    /** Amount of silence (in ms) to wait for */\n\n    this.silenceTime = 1500;\n    /** Noise threshold between -1 and 1. Anything below is considered a silence. */\n\n    this.silenceThreshold = 0.2;\n    /** Messages in current session */\n\n    this.messages = [];\n    /** Text input box value  */\n\n    this.text = '';\n    /** Current app state */\n\n    this.chatState = ChatState.Initial;\n    /**\n     * Rendering methods\n     */\n\n    this.messageJSX = messages => {\n      const messageList = messages.map(message => h(\"div\", {\n        class: `bubble ${message.from}`\n      }, message.content));\n\n      if (this.chatState === ChatState.SendingText || this.chatState === ChatState.SendingVoice) {\n        // if waiting for voice message, show animation on user side because app is waiting for transcript. Else put it on bot side.\n        const client = this.chatState === ChatState.SendingText ? MessageFrom.Bot : MessageFrom.User;\n        messageList.push(h(\"div\", {\n          class: `bubble ${client}`\n        }, h(\"div\", {\n          class: `dot-flashing ${client}`\n        }, h(\"span\", {\n          class: \"dot left\"\n        }), h(\"span\", {\n          class: \"dot middle\"\n        }), h(\"span\", {\n          class: \"dot right\"\n        }))));\n      }\n\n      return messageList;\n    };\n\n    this.chatCompleted = createEvent(this, \"chatCompleted\", 7);\n  } // Occurs when user presses enter in input box\n\n\n  submitHandler(_event) {\n    this.sendTextMessage();\n  }\n  /**\n   * Lifecycle functions\n   */\n\n\n  componentWillLoad() {\n    if (!Interactions || typeof Interactions.onComplete !== 'function') {\n      throw new Error(NO_INTERACTIONS_MODULE_FOUND);\n    }\n\n    this.validateProps();\n  }\n\n  componentDidRender() {\n    // scroll to the bottom if necessary\n    const body = this.element.shadowRoot.querySelector('.body');\n    body.scrollTop = body.scrollHeight;\n  }\n\n  validateProps() {\n    if (!this.voiceEnabled && !this.textEnabled) {\n      this.setError(Translations.CHAT_DISABLED_ERROR, ChatErrorType.Unrecoverable);\n      return;\n    } else if (!this.botName) {\n      this.setError(Translations.NO_BOT_NAME_ERROR, ChatErrorType.Unrecoverable);\n      return;\n    }\n\n    if (this.welcomeMessage) this.appendToChat(this.welcomeMessage, MessageFrom.Bot); // Initialize AudioRecorder if voice is enabled\n\n    if (this.voiceEnabled) {\n      this.audioRecorder = new AudioRecorder({\n        time: this.silenceTime,\n        amplitude: this.silenceThreshold\n      });\n      this.audioRecorder.init().catch(err => {\n        this.setError(err, ChatErrorType.Recoverable);\n      });\n    } // Callback function to be called after chat is completed\n\n\n    const onComplete = (err, data) => {\n      this.chatCompleted.emit({\n        data,\n        err\n      });\n\n      if (this.clearOnComplete) {\n        this.reset();\n      } else {\n        this.chatState = ChatState.Initial;\n      }\n    };\n\n    try {\n      Interactions.onComplete(this.botName, onComplete);\n    } catch (err) {\n      this.setError(err, ChatErrorType.Unrecoverable);\n    }\n  }\n  /**\n   * Handlers\n   */\n\n\n  handleSubmit(event) {\n    event.preventDefault();\n    this.sendTextMessage();\n  }\n\n  handleMicButton() {\n    if (this.chatState !== ChatState.Initial) return;\n    this.audioRecorder.stop();\n    this.chatState = ChatState.Listening;\n    this.audioRecorder.startRecording(() => this.handleSilence(), (data, length) => this.visualizer(data, length));\n  }\n\n  handleSilence() {\n    this.chatState = ChatState.SendingVoice;\n    this.audioRecorder.stopRecording();\n    this.audioRecorder.exportWAV().then(blob => {\n      this.sendVoiceMessage(blob);\n    });\n  }\n\n  handleTextChange(event) {\n    const target = event.target;\n    this.text = target.value;\n  }\n\n  handleCancelButton() {\n    this.audioRecorder.clear();\n    this.chatState = ChatState.Initial;\n  }\n\n  handleToastClose(errorType) {\n    this.error = undefined; // clear error\n    // if error is recoverable, reset the app state to initial\n\n    if (errorType === ChatErrorType.Recoverable) {\n      this.chatState = ChatState.Initial;\n    }\n  }\n  /**\n   * Visualization\n   */\n\n\n  visualizer(dataArray, bufferLength) {\n    const canvas = this.element.shadowRoot.querySelector('canvas');\n    visualize(dataArray, bufferLength, canvas);\n  }\n  /**\n   * Interactions helpers\n   */\n\n\n  sendTextMessage() {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this5.text.length === 0 || _this5.chatState !== ChatState.Initial) return;\n      const text = _this5.text;\n      _this5.text = '';\n\n      _this5.appendToChat(text, MessageFrom.User);\n\n      _this5.chatState = ChatState.SendingText;\n      let response;\n\n      try {\n        response = yield Interactions.send(_this5.botName, text);\n      } catch (err) {\n        _this5.setError(err, ChatErrorType.Recoverable);\n\n        return;\n      }\n\n      if (response.message) {\n        _this5.appendToChat(response.message, MessageFrom.Bot);\n      }\n\n      _this5.chatState = ChatState.Initial;\n    })();\n  }\n\n  sendVoiceMessage(audioInput) {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      const interactionsMessage = {\n        content: audioInput,\n        options: {\n          messageType: 'voice'\n        }\n      };\n      let response;\n\n      try {\n        response = yield Interactions.send(_this6.botName, interactionsMessage);\n      } catch (err) {\n        _this6.setError(err, ChatErrorType.Recoverable);\n\n        return;\n      }\n\n      _this6.chatState = ChatState.Initial;\n      const dialogState = response.dialogState;\n      if (response.inputTranscript) _this6.appendToChat(response.inputTranscript, MessageFrom.User);\n\n      _this6.appendToChat(response.message, MessageFrom.Bot);\n\n      yield _this6.audioRecorder.play(response.audioStream).then(() => {\n        // if conversationMode is on, chat is incomplete, and mic button isn't pressed yet, resume listening.\n        if (_this6.conversationModeOn && dialogState !== 'Fulfilled' && dialogState !== 'Failed' && _this6.chatState === ChatState.Initial) {\n          _this6.handleMicButton();\n        }\n      }).catch(err => _this6.setError(err, ChatErrorType.Recoverable));\n    })();\n  }\n\n  appendToChat(content, from) {\n    this.messages = [...this.messages, {\n      content,\n      from\n    }];\n  }\n  /**\n   * State control methods\n   */\n\n\n  setError(error, errorType) {\n    const message = typeof error === 'string' ? error : error.message;\n    this.chatState = ChatState.Error;\n    this.error = {\n      message,\n      errorType\n    };\n  }\n\n  reset() {\n    this.chatState = ChatState.Initial;\n    this.text = '';\n    this.error = undefined;\n    this.messages = [];\n    if (this.welcomeMessage) this.appendToChat(this.welcomeMessage, MessageFrom.Bot);\n    this.audioRecorder && this.audioRecorder.clear();\n  }\n\n  listeningFooterJSX() {\n    const visualization = h(\"canvas\", {\n      height: \"50\"\n    });\n    const cancelButton = h(\"amplify-button\", {\n      \"data-test\": \"chatbot-cancel-button\",\n      handleButtonClick: () => this.handleCancelButton(),\n      class: \"icon-button\",\n      variant: \"icon\",\n      icon: \"ban\"\n    });\n    return [visualization, cancelButton];\n  }\n\n  footerJSX() {\n    if (this.chatState === ChatState.Listening) return this.listeningFooterJSX();\n    const inputPlaceholder = this.textEnabled ? Translations.TEXT_INPUT_PLACEHOLDER : Translations.VOICE_INPUT_PLACEHOLDER;\n    const textInput = h(\"amplify-input\", {\n      placeholder: I18n.get(inputPlaceholder),\n      description: \"text\",\n      handleInputChange: evt => this.handleTextChange(evt),\n      value: this.text,\n      disabled: this.chatState === ChatState.Error || !this.textEnabled\n    });\n    const micButton = this.voiceEnabled && h(\"amplify-button\", {\n      \"data-test\": \"chatbot-mic-button\",\n      handleButtonClick: () => this.handleMicButton(),\n      class: \"icon-button\",\n      variant: \"icon\",\n      icon: \"microphone\",\n      disabled: this.chatState === ChatState.Error || this.chatState !== ChatState.Initial\n    });\n    const sendButton = this.textEnabled && h(\"amplify-button\", {\n      \"data-test\": \"chatbot-send-button\",\n      class: \"icon-button\",\n      variant: \"icon\",\n      icon: \"send\",\n      handleButtonClick: () => this.sendTextMessage(),\n      disabled: this.chatState === ChatState.Error || this.chatState !== ChatState.Initial\n    });\n    return [textInput, micButton, sendButton];\n  }\n\n  errorToast() {\n    if (!this.error) return;\n    const {\n      message,\n      errorType\n    } = this.error;\n    return h(\"amplify-toast\", {\n      message: I18n.get(message),\n      handleClose: () => this.handleToastClose(errorType)\n    });\n  }\n\n  render() {\n    return h(Host, null, h(\"div\", {\n      class: \"amplify-chatbot\"\n    }, h(\"slot\", {\n      name: \"header\"\n    }, h(\"div\", {\n      class: \"header\",\n      \"data-test\": \"chatbot-header\"\n    }, I18n.get(this.botTitle))), h(\"div\", {\n      class: \"body\",\n      \"data-test\": \"chatbot-body\"\n    }, this.messageJSX(this.messages)), h(\"form\", {\n      onSubmit: e => this.handleSubmit(e)\n    }, h(\"div\", {\n      class: \"footer\",\n      \"data-test\": \"chatbot-footer\"\n    }, this.footerJSX())), this.errorToast()));\n  }\n\n  get element() {\n    return getElement(this);\n  }\n\n};\nAmplifyChatbot.style = amplifyChatbotCss;\nexport { AmplifyChatbot as amplify_chatbot };","map":{"version":3,"sources":["C:/Users/eriki/Documents/GitHub/amplify-app/node_modules/@aws-amplify/ui-components/dist/esm/amplify-chatbot.entry.js"],"names":["r","registerInstance","h","c","createEvent","H","Host","g","getElement","Logger","browserOrNode","I18n","T","Translations","NO_INTERACTIONS_MODULE_FOUND","Interactions","RECORDER_EXPORT_MIME_TYPE","DEFAULT_EXPORT_SAMPLE_RATE","FFT_SIZE","FFT_MAX_DECIBELS","FFT_MIN_DECIBELS","FFT_SMOOTHING_TIME_CONSTANT","mergeBuffers","bufferArray","recLength","result","Float32Array","offset","i","length","set","downsampleBuffer","buffer","recordSampleRate","exportSampleRate","sampleRateRatio","newLength","Math","round","offsetResult","offsetBuffer","nextOffsetBuffer","accum","count","floatTo16BitPCM","output","input","byteOffset","s","max","min","setInt16","writeString","view","string","setUint8","charCodeAt","encodeWAV","samples","audioSize","fmtSize","dataSize","totalByteSize","ArrayBuffer","DataView","setUint32","setUint16","exportBuffer","recBuffer","mergedBuffers","downsampledBuffer","encodedWav","audioBlob","Blob","type","logger","AudioRecorder","constructor","options","streamBuffer","streamBufferLength","recording","init","isBrowser","window","AudioContext","webkitAudioContext","audioContext","navigator","mediaDevices","getUserMedia","audio","then","stream","audioSupported","setupAudioNodes","catch","Promise","reject","resume","err","error","sourceNode","createMediaStreamSource","processorNode","createScriptProcessor","onaudioprocess","audioProcessingEvent","inputBuffer","getChannelData","push","analyse","analyserNode","createAnalyser","minDecibels","maxDecibels","smoothingTimeConstant","connect","context","destination","startRecording","onSilence","visualizer","start","Date","now","stopRecording","clear","play","myBlob","res","rej","fileReader","FileReader","onload","playbackSource","disconnect","createBufferSource","successCallback","buf","onended","errorCallback","decodeAudioData","onerror","readAsArrayBuffer","stop","analyser","fftSize","bufferLength","dataArray","Uint8Array","amplitude","time","getByteTimeDomainData","curr_value_time","newtime","elapsedTime","exportWAV","sampleRate","blob","visualize","canvas","Error","width","height","getBoundingClientRect","canvasCtx","getContext","fillStyle","clearRect","draw","fillRect","lineWidth","color","getComputedStyle","document","documentElement","getPropertyValue","strokeStyle","beginPath","sliceWidth","x","value","y","moveTo","lineTo","stroke","requestAnimationFrame","amplifyChatbotCss","ChatState","MessageFrom","ChatErrorType","AmplifyChatbot","hostRef","clearOnComplete","conversationModeOn","botTitle","CHATBOT_TITLE","voiceEnabled","textEnabled","silenceTime","silenceThreshold","messages","text","chatState","Initial","messageJSX","messageList","map","message","class","from","content","SendingText","SendingVoice","client","Bot","User","chatCompleted","submitHandler","_event","sendTextMessage","componentWillLoad","onComplete","validateProps","componentDidRender","body","element","shadowRoot","querySelector","scrollTop","scrollHeight","setError","CHAT_DISABLED_ERROR","Unrecoverable","botName","NO_BOT_NAME_ERROR","welcomeMessage","appendToChat","audioRecorder","Recoverable","data","emit","reset","handleSubmit","event","preventDefault","handleMicButton","Listening","handleSilence","sendVoiceMessage","handleTextChange","target","handleCancelButton","handleToastClose","errorType","undefined","response","send","audioInput","interactionsMessage","messageType","dialogState","inputTranscript","audioStream","listeningFooterJSX","visualization","cancelButton","handleButtonClick","variant","icon","footerJSX","inputPlaceholder","TEXT_INPUT_PLACEHOLDER","VOICE_INPUT_PLACEHOLDER","textInput","placeholder","get","description","handleInputChange","evt","disabled","micButton","sendButton","errorToast","handleClose","render","name","onSubmit","e","style","amplify_chatbot"],"mappings":"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","sourcesContent":["import { r as registerInstance, h, c as createEvent, H as Host, g as getElement } from './index-83f2275b.js';\nimport { Logger, browserOrNode, I18n } from '@aws-amplify/core';\nimport '@aws-amplify/auth';\nimport { T as Translations } from './Translations-c833f663.js';\nimport { c as NO_INTERACTIONS_MODULE_FOUND } from './constants-c8ecaa24.js';\nimport { Interactions } from '@aws-amplify/interactions';\n\n// AudioRecorder settings\nconst RECORDER_EXPORT_MIME_TYPE = 'application/octet-stream';\nconst DEFAULT_EXPORT_SAMPLE_RATE = 16000;\nconst FFT_SIZE = 2048; // window size in samples for Fast Fourier Transform (FFT)\nconst FFT_MAX_DECIBELS = -10; // maximum power value in the scaling range for the FFT analysis data\nconst FFT_MIN_DECIBELS = -90; // minimum power value in the scaling range for the FFT analysis data\nconst FFT_SMOOTHING_TIME_CONSTANT = 0.85; // averaging constant with the last analysis frame\n\n/**\n * Merges multiple buffers into one.\n */\nconst mergeBuffers = (bufferArray, recLength) => {\n    const result = new Float32Array(recLength);\n    let offset = 0;\n    for (let i = 0; i < bufferArray.length; i++) {\n        result.set(bufferArray[i], offset);\n        offset += bufferArray[i].length;\n    }\n    return result;\n};\n/**\n * Downsamples audio to desired export sample rate.\n */\nconst downsampleBuffer = (buffer, recordSampleRate, exportSampleRate) => {\n    if (exportSampleRate === recordSampleRate) {\n        return buffer;\n    }\n    const sampleRateRatio = recordSampleRate / exportSampleRate;\n    const newLength = Math.round(buffer.length / sampleRateRatio);\n    const result = new Float32Array(newLength);\n    let offsetResult = 0;\n    let offsetBuffer = 0;\n    while (offsetResult < result.length) {\n        const nextOffsetBuffer = Math.round((offsetResult + 1) * sampleRateRatio);\n        let accum = 0, count = 0;\n        for (let i = offsetBuffer; i < nextOffsetBuffer && i < buffer.length; i++) {\n            accum += buffer[i];\n            count++;\n        }\n        result[offsetResult] = accum / count;\n        offsetResult++;\n        offsetBuffer = nextOffsetBuffer;\n    }\n    return result;\n};\n/**\n * converts raw audio values to 16 bit pcm.\n */\nconst floatTo16BitPCM = (output, offset, input) => {\n    let byteOffset = offset;\n    for (let i = 0; i < input.length; i++, byteOffset += 2) {\n        const s = Math.max(-1, Math.min(1, input[i]));\n        output.setInt16(byteOffset, s < 0 ? s * 0x8000 : s * 0x7fff, true);\n    }\n};\n/**\n * Write given strings in big-endian order.\n */\nconst writeString = (view, offset, string) => {\n    for (let i = 0; i < string.length; i++) {\n        view.setUint8(offset + i, string.charCodeAt(i));\n    }\n};\n/**\n * Encodes raw pcm audio into a wav file.\n */\nconst encodeWAV = (samples, exportSampleRate) => {\n    /**\n     * WAV file consists of three parts: RIFF header, WAVE subchunk, and data subchunk. We precompute the size of them.\n     */\n    const audioSize = samples.length * 2; // We use 16-bit samples, so we have (2 * sampleLength) bytes.\n    const fmtSize = 24; // Byte size of the fmt subchunk: 24 bytes that the audio information that we'll set below.\n    const dataSize = 8 + audioSize; // Byte size of the data subchunk: raw sound data plus 8 bytes for the subchunk descriptions.\n    const totalByteSize = 12 + fmtSize + dataSize; // Byte size of the whole file, including the chunk header / descriptor.\n    // create DataView object to write byte values into\n    const buffer = new ArrayBuffer(totalByteSize); // buffer to write the chunk values in.\n    const view = new DataView(buffer);\n    /**\n     * Start writing the .wav file. We write top to bottom, so byte offset (first numeric argument) increases strictly.\n     */\n    // RIFF header\n    writeString(view, 0, 'RIFF'); // At offset 0, write the letters \"RIFF\"\n    view.setUint32(4, fmtSize + dataSize, true); // At offset 4, write the size of fmt and data chunk size combined.\n    writeString(view, 8, 'WAVE'); // At offset 8, write the format type \"WAVE\"\n    // fmt subchunk\n    writeString(view, 12, 'fmt '); //chunkdId 'fmt '\n    view.setUint32(16, fmtSize - 8, true); // fmt subchunk size below this value. We set 8 bytes already, so subtract 8 bytes from fmtSize.\n    view.setUint16(20, 1, true); // Audio format code, which is 1 for PCM.\n    view.setUint16(22, 1, true); // Number of audio channels. We use mono, ie 1.\n    view.setUint32(24, exportSampleRate, true); // Sample rate of the audio file.\n    view.setUint32(28, exportSampleRate * 2, true); // Data rate, or # of data bytes per second. Since each sample is 2 bytes, this is 2 * sampleRate.\n    view.setUint16(32, 2, true); // block align, # of bytes per sample including all channels, ie. 2 bytes.\n    view.setUint16(34, 16, true); // bits per sample, ie. 16 bits\n    // data subchunk\n    writeString(view, 36, 'data'); // write the chunkId 'data'\n    view.setUint32(40, audioSize, true); // Audio byte size\n    floatTo16BitPCM(view, 44, samples); // raw pcm values then go here.\n    return view;\n};\n/**\n * Given arrays of raw pcm audio, downsamples the audio to desired sample rate and encodes it to a wav audio file.\n *\n * @param recBuffer {Float32Array[]} - 2d float array containing the recorded raw audio\n * @param recLength {number} - total length of recorded audio\n * @param recordSampleRate {number} - sample rate of the recorded audio\n * @param exportSampleRate {number} - desired sample rate of the exported file\n */\nconst exportBuffer = (recBuffer, recLength, recordSampleRate, exportSampleRate) => {\n    const mergedBuffers = mergeBuffers(recBuffer, recLength);\n    const downsampledBuffer = downsampleBuffer(mergedBuffers, recordSampleRate, exportSampleRate);\n    const encodedWav = encodeWAV(downsampledBuffer, exportSampleRate);\n    const audioBlob = new Blob([encodedWav], {\n        type: RECORDER_EXPORT_MIME_TYPE,\n    });\n    return audioBlob;\n};\n\nconst logger = new Logger('AudioRecorder');\nclass AudioRecorder {\n    constructor(options) {\n        // input mic stream is stored in a buffer\n        this.streamBuffer = [];\n        this.streamBufferLength = 0;\n        this.recording = false;\n        this.options = options;\n    }\n    /**\n     * This must be called first to enable audio context and request microphone access.\n     * Once access granted, it connects all the necessary audio nodes to the context so that it can begin recording or playing.\n     */\n    async init() {\n        if (browserOrNode().isBrowser) {\n            window.AudioContext =\n                window.AudioContext || window.webkitAudioContext;\n            this.audioContext = new AudioContext();\n            await navigator.mediaDevices\n                .getUserMedia({ audio: true })\n                .then(stream => {\n                this.audioSupported = true;\n                this.setupAudioNodes(stream);\n            })\n                .catch(() => {\n                this.audioSupported = false;\n                return Promise.reject('Audio is not supported');\n            });\n        }\n        else {\n            this.audioSupported = false;\n            return Promise.reject('Audio is not supported');\n        }\n    }\n    /**\n     * Setup audio nodes after successful `init`.\n     */\n    async setupAudioNodes(stream) {\n        try {\n            await this.audioContext.resume();\n        }\n        catch (err) {\n            logger.error(err);\n        }\n        const sourceNode = this.audioContext.createMediaStreamSource(stream);\n        const processorNode = this.audioContext.createScriptProcessor(4096, 1, 1);\n        processorNode.onaudioprocess = audioProcessingEvent => {\n            if (!this.recording)\n                return;\n            const stream = audioProcessingEvent.inputBuffer.getChannelData(0);\n            this.streamBuffer.push(new Float32Array(stream)); // set to a copy of the stream\n            this.streamBufferLength += stream.length;\n            this.analyse();\n        };\n        const analyserNode = this.audioContext.createAnalyser();\n        analyserNode.minDecibels = FFT_MIN_DECIBELS;\n        analyserNode.maxDecibels = FFT_MAX_DECIBELS;\n        analyserNode.smoothingTimeConstant = FFT_SMOOTHING_TIME_CONSTANT;\n        sourceNode.connect(analyserNode);\n        analyserNode.connect(processorNode);\n        processorNode.connect(sourceNode.context.destination);\n        this.analyserNode = analyserNode;\n    }\n    /**\n     * Start recording audio and listen for silence.\n     *\n     * @param onSilence {SilenceHandler} - called whenever silence is detected\n     * @param visualizer {Visualizer} - called with audio data on each audio process to be used for visualization.\n     */\n    async startRecording(onSilence, visualizer) {\n        if (this.recording || !this.audioSupported)\n            return;\n        this.onSilence = onSilence || function () { };\n        this.visualizer = visualizer || function () { };\n        const context = this.audioContext;\n        try {\n            await context.resume();\n        }\n        catch (err) {\n            logger.error(err);\n        }\n        this.start = Date.now();\n        this.recording = true;\n    }\n    /**\n     * Pause recording\n     */\n    stopRecording() {\n        if (!this.audioSupported)\n            return;\n        this.recording = false;\n    }\n    /**\n     * Pause recording and clear audio buffer\n     */\n    clear() {\n        this.stopRecording();\n        this.streamBufferLength = 0;\n        this.streamBuffer = [];\n    }\n    /**\n     * Plays given audioStream with audioContext\n     *\n     * @param buffer {Uint8Array} - audioStream to be played\n     */\n    play(buffer) {\n        if (!buffer || !this.audioSupported)\n            return;\n        const myBlob = new Blob([buffer]);\n        return new Promise((res, rej) => {\n            const fileReader = new FileReader();\n            fileReader.onload = () => {\n                if (this.playbackSource)\n                    this.playbackSource.disconnect(); // disconnect previous playback source\n                this.playbackSource = this.audioContext.createBufferSource();\n                const successCallback = (buf) => {\n                    this.playbackSource.buffer = buf;\n                    this.playbackSource.connect(this.audioContext.destination);\n                    this.playbackSource.onended = () => {\n                        return res();\n                    };\n                    this.playbackSource.start(0);\n                };\n                const errorCallback = err => {\n                    return rej(err);\n                };\n                this.audioContext.decodeAudioData(fileReader.result, successCallback, errorCallback);\n            };\n            fileReader.onerror = () => rej();\n            fileReader.readAsArrayBuffer(myBlob);\n        });\n    }\n    /**\n     * Stops playing audio if there's a playback source connected.\n     */\n    stop() {\n        if (this.playbackSource) {\n            this.playbackSource.stop();\n        }\n    }\n    /**\n     * Called after each audioProcess. Check for silence and give fft time domain data to visualizer.\n     */\n    analyse() {\n        if (!this.audioSupported)\n            return;\n        const analyser = this.analyserNode;\n        analyser.fftSize = FFT_SIZE;\n        const bufferLength = analyser.fftSize;\n        const dataArray = new Uint8Array(bufferLength);\n        const amplitude = this.options.amplitude;\n        const time = this.options.time;\n        analyser.getByteTimeDomainData(dataArray);\n        this.visualizer(dataArray, bufferLength);\n        for (let i = 0; i < bufferLength; i++) {\n            // Normalize between -1 and 1.\n            const curr_value_time = dataArray[i] / 128 - 1.0;\n            if (curr_value_time > amplitude || curr_value_time < -1 * amplitude) {\n                this.start = Date.now();\n            }\n        }\n        const newtime = Date.now();\n        const elapsedTime = newtime - this.start;\n        if (elapsedTime > time) {\n            this.onSilence();\n        }\n    }\n    /**\n     * Encodes recorded buffer to a wav file and exports it to a blob.\n     *\n     * @param exportSampleRate {number} - desired sample rate of the exported buffer\n     */\n    async exportWAV(exportSampleRate = DEFAULT_EXPORT_SAMPLE_RATE) {\n        if (!this.audioSupported)\n            return;\n        const recordSampleRate = this.audioContext.sampleRate;\n        const blob = exportBuffer(this.streamBuffer, this.streamBufferLength, recordSampleRate, exportSampleRate);\n        this.clear();\n        return blob;\n    }\n}\n\nconst visualize = (dataArray, bufferLength, canvas) => {\n    if (!canvas)\n        return;\n    if (!browserOrNode().isBrowser)\n        throw new Error('Visualization is not supported on non-browsers.');\n    const { width, height } = canvas.getBoundingClientRect();\n    // need to update the default canvas width and height\n    canvas.width = width;\n    canvas.height = height;\n    const canvasCtx = canvas.getContext('2d');\n    canvasCtx.fillStyle = 'white';\n    canvasCtx.clearRect(0, 0, width, height);\n    const draw = () => {\n        canvasCtx.fillRect(0, 0, width, height);\n        canvasCtx.lineWidth = 1;\n        const color = getComputedStyle(document.documentElement).getPropertyValue('--amplify-primary-color');\n        canvasCtx.strokeStyle = !color || color === '' ? '#ff9900' : color; // TODO: try separate css variable\n        canvasCtx.beginPath();\n        const sliceWidth = (width * 1.0) / bufferLength;\n        let x = 0;\n        for (let i = 0; i < bufferLength || i % 3 === 0; i++) {\n            const value = dataArray[i] / 128.0;\n            const y = (value * height) / 2;\n            if (i === 0) {\n                canvasCtx.moveTo(x, y);\n            }\n            else {\n                canvasCtx.lineTo(x, y);\n            }\n            x += sliceWidth;\n        }\n        canvasCtx.lineTo(canvas.width, canvas.height / 2);\n        canvasCtx.stroke();\n    };\n    // Register our draw function with requestAnimationFrame.\n    requestAnimationFrame(draw);\n};\n\nconst amplifyChatbotCss = \".bot .dot{background-color:var(--bot-dot-color)}.user .dot{background-color:var(--user-dot-color)}.dot-flashing{width:2.625rem}.dot-flashing .dot{display:inline-block;width:0.625rem;height:0.625rem;border-radius:10rem;opacity:0.65}.dot-flashing .left{-webkit-animation:dot-flashing 1s infinite alternate;animation:dot-flashing 1s infinite alternate;-webkit-animation-delay:0s;animation-delay:0s}.dot-flashing .middle{margin-left:0.375rem;margin-right:0.375rem;-webkit-animation:dot-flashing 1s infinite linear alternate;animation:dot-flashing 1s infinite linear alternate;-webkit-animation-delay:0.5s;animation-delay:0.5s}.dot-flashing .right{-webkit-animation:dot-flashing 1s infinite alternate;animation:dot-flashing 1s infinite alternate;-webkit-animation-delay:1s;animation-delay:1s}@-webkit-keyframes dot-flashing{0%{opacity:0.65}50%,100%{opacity:0.1}}@keyframes dot-flashing{0%{opacity:0.65}50%,100%{opacity:0.1}}:host{--width:28.75rem;--height:37.5rem;--header-color:var(--amplify-secondary-color);--header-size:var(--amplify-text-lg);--bot-background-color:rgb(230, 230, 230);--bot-text-color:black;--bot-dot-color:var(--bot-text-color);--user-background-color:var(--amplify-blue);--user-text-color:var(--amplify-white);--user-dot-color:var(--user-text-color)}.amplify-chatbot{display:-ms-inline-flexbox;display:inline-flex;-ms-flex-direction:column;flex-direction:column;background-color:var(--background-color);border-radius:0.375rem;-webkit-box-shadow:0.0625rem 0rem 0.25rem 0 rgba(0, 0, 0, 0.15);box-shadow:0.0625rem 0rem 0.25rem 0 rgba(0, 0, 0, 0.15);-webkit-box-sizing:border-box;box-sizing:border-box;font-family:var(--amplify-font-family);margin-bottom:1rem;width:100%;height:var(--height);max-width:var(--width)}@media (min-width: 672px){.amplify-chatbot{width:var(--width)}}.header{padding:1.25rem 0.375rem 1.25rem 0.375rem;color:var(--header-color);font-size:var(--header-size);font-weight:bold;text-align:center;word-wrap:break-word}.body{border-top:0.0625rem solid rgba(0, 0, 0, 0.05);padding:1.5rem 1rem 0 1rem;display:-ms-flexbox;display:flex;-ms-flex-positive:1;flex-grow:1;-ms-flex-direction:column;flex-direction:column;overflow:auto}.bubble{max-width:100%;padding:0.8em 1.4em;text-align:left;word-wrap:break-word;margin-bottom:0.625rem}.bot{margin-right:auto;background-color:var(--bot-background-color);color:var(--bot-text-color);border-radius:1.5rem 1.5rem 1.5rem 0}.user{margin-left:auto;background-color:var(--user-background-color);color:var(--user-text-color);border-radius:1.5rem 1.5rem 0 1.5rem}.footer{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;border-top:0.062rem solid rgba(0, 0, 0, 0.05);padding-right:0.625rem;min-height:3.125rem}.footer amplify-input{--border:none;--margin:0;-ms-flex-positive:1;flex-grow:1}canvas{margin-left:0.625rem;margin-right:0.625rem;-ms-flex-positive:1;flex-grow:1;height:3.125rem}.icon-button{--icon-height:1.25rem;--icon-fill:var(--amplify-primary-color);--padding:0.625rem;--width:auto}\";\n\n// enum for possible bot states\nvar ChatState;\n(function (ChatState) {\n    ChatState[ChatState[\"Initial\"] = 0] = \"Initial\";\n    ChatState[ChatState[\"Listening\"] = 1] = \"Listening\";\n    ChatState[ChatState[\"SendingText\"] = 2] = \"SendingText\";\n    ChatState[ChatState[\"SendingVoice\"] = 3] = \"SendingVoice\";\n    ChatState[ChatState[\"Error\"] = 4] = \"Error\";\n})(ChatState || (ChatState = {}));\n// Message types\nvar MessageFrom;\n(function (MessageFrom) {\n    MessageFrom[\"Bot\"] = \"bot\";\n    MessageFrom[\"User\"] = \"user\";\n})(MessageFrom || (MessageFrom = {}));\n// Error types\nvar ChatErrorType;\n(function (ChatErrorType) {\n    ChatErrorType[ChatErrorType[\"Recoverable\"] = 0] = \"Recoverable\";\n    ChatErrorType[ChatErrorType[\"Unrecoverable\"] = 1] = \"Unrecoverable\";\n})(ChatErrorType || (ChatErrorType = {}));\nconst AmplifyChatbot = class {\n    constructor(hostRef) {\n        registerInstance(this, hostRef);\n        /** Clear messages when conversation finishes */\n        this.clearOnComplete = false;\n        /** Continue listening to users after they send the message */\n        this.conversationModeOn = false;\n        /** Text placed in the top header */\n        this.botTitle = Translations.CHATBOT_TITLE;\n        /** Whether voice chat is enabled */\n        this.voiceEnabled = false;\n        /** Whether text chat is enabled */\n        this.textEnabled = true;\n        /** Amount of silence (in ms) to wait for */\n        this.silenceTime = 1500;\n        /** Noise threshold between -1 and 1. Anything below is considered a silence. */\n        this.silenceThreshold = 0.2;\n        /** Messages in current session */\n        this.messages = [];\n        /** Text input box value  */\n        this.text = '';\n        /** Current app state */\n        this.chatState = ChatState.Initial;\n        /**\n         * Rendering methods\n         */\n        this.messageJSX = (messages) => {\n            const messageList = messages.map(message => (h(\"div\", { class: `bubble ${message.from}` }, message.content)));\n            if (this.chatState === ChatState.SendingText ||\n                this.chatState === ChatState.SendingVoice) {\n                // if waiting for voice message, show animation on user side because app is waiting for transcript. Else put it on bot side.\n                const client = this.chatState === ChatState.SendingText\n                    ? MessageFrom.Bot\n                    : MessageFrom.User;\n                messageList.push(h(\"div\", { class: `bubble ${client}` }, h(\"div\", { class: `dot-flashing ${client}` }, h(\"span\", { class: \"dot left\" }), h(\"span\", { class: \"dot middle\" }), h(\"span\", { class: \"dot right\" }))));\n            }\n            return messageList;\n        };\n        this.chatCompleted = createEvent(this, \"chatCompleted\", 7);\n    }\n    // Occurs when user presses enter in input box\n    submitHandler(_event) {\n        this.sendTextMessage();\n    }\n    /**\n     * Lifecycle functions\n     */\n    componentWillLoad() {\n        if (!Interactions || typeof Interactions.onComplete !== 'function') {\n            throw new Error(NO_INTERACTIONS_MODULE_FOUND);\n        }\n        this.validateProps();\n    }\n    componentDidRender() {\n        // scroll to the bottom if necessary\n        const body = this.element.shadowRoot.querySelector('.body');\n        body.scrollTop = body.scrollHeight;\n    }\n    validateProps() {\n        if (!this.voiceEnabled && !this.textEnabled) {\n            this.setError(Translations.CHAT_DISABLED_ERROR, ChatErrorType.Unrecoverable);\n            return;\n        }\n        else if (!this.botName) {\n            this.setError(Translations.NO_BOT_NAME_ERROR, ChatErrorType.Unrecoverable);\n            return;\n        }\n        if (this.welcomeMessage)\n            this.appendToChat(this.welcomeMessage, MessageFrom.Bot);\n        // Initialize AudioRecorder if voice is enabled\n        if (this.voiceEnabled) {\n            this.audioRecorder = new AudioRecorder({\n                time: this.silenceTime,\n                amplitude: this.silenceThreshold,\n            });\n            this.audioRecorder.init().catch(err => {\n                this.setError(err, ChatErrorType.Recoverable);\n            });\n        }\n        // Callback function to be called after chat is completed\n        const onComplete = (err, data) => {\n            this.chatCompleted.emit({\n                data,\n                err,\n            });\n            if (this.clearOnComplete) {\n                this.reset();\n            }\n            else {\n                this.chatState = ChatState.Initial;\n            }\n        };\n        try {\n            Interactions.onComplete(this.botName, onComplete);\n        }\n        catch (err) {\n            this.setError(err, ChatErrorType.Unrecoverable);\n        }\n    }\n    /**\n     * Handlers\n     */\n    handleSubmit(event) {\n        event.preventDefault();\n        this.sendTextMessage();\n    }\n    handleMicButton() {\n        if (this.chatState !== ChatState.Initial)\n            return;\n        this.audioRecorder.stop();\n        this.chatState = ChatState.Listening;\n        this.audioRecorder.startRecording(() => this.handleSilence(), (data, length) => this.visualizer(data, length));\n    }\n    handleSilence() {\n        this.chatState = ChatState.SendingVoice;\n        this.audioRecorder.stopRecording();\n        this.audioRecorder.exportWAV().then(blob => {\n            this.sendVoiceMessage(blob);\n        });\n    }\n    handleTextChange(event) {\n        const target = event.target;\n        this.text = target.value;\n    }\n    handleCancelButton() {\n        this.audioRecorder.clear();\n        this.chatState = ChatState.Initial;\n    }\n    handleToastClose(errorType) {\n        this.error = undefined; // clear error\n        // if error is recoverable, reset the app state to initial\n        if (errorType === ChatErrorType.Recoverable) {\n            this.chatState = ChatState.Initial;\n        }\n    }\n    /**\n     * Visualization\n     */\n    visualizer(dataArray, bufferLength) {\n        const canvas = this.element.shadowRoot.querySelector('canvas');\n        visualize(dataArray, bufferLength, canvas);\n    }\n    /**\n     * Interactions helpers\n     */\n    async sendTextMessage() {\n        if (this.text.length === 0 || this.chatState !== ChatState.Initial)\n            return;\n        const text = this.text;\n        this.text = '';\n        this.appendToChat(text, MessageFrom.User);\n        this.chatState = ChatState.SendingText;\n        let response;\n        try {\n            response = await Interactions.send(this.botName, text);\n        }\n        catch (err) {\n            this.setError(err, ChatErrorType.Recoverable);\n            return;\n        }\n        if (response.message) {\n            this.appendToChat(response.message, MessageFrom.Bot);\n        }\n        this.chatState = ChatState.Initial;\n    }\n    async sendVoiceMessage(audioInput) {\n        const interactionsMessage = {\n            content: audioInput,\n            options: {\n                messageType: 'voice',\n            },\n        };\n        let response;\n        try {\n            response = await Interactions.send(this.botName, interactionsMessage);\n        }\n        catch (err) {\n            this.setError(err, ChatErrorType.Recoverable);\n            return;\n        }\n        this.chatState = ChatState.Initial;\n        const dialogState = response.dialogState;\n        if (response.inputTranscript)\n            this.appendToChat(response.inputTranscript, MessageFrom.User);\n        this.appendToChat(response.message, MessageFrom.Bot);\n        await this.audioRecorder\n            .play(response.audioStream)\n            .then(() => {\n            // if conversationMode is on, chat is incomplete, and mic button isn't pressed yet, resume listening.\n            if (this.conversationModeOn &&\n                dialogState !== 'Fulfilled' &&\n                dialogState !== 'Failed' &&\n                this.chatState === ChatState.Initial) {\n                this.handleMicButton();\n            }\n        })\n            .catch(err => this.setError(err, ChatErrorType.Recoverable));\n    }\n    appendToChat(content, from) {\n        this.messages = [\n            ...this.messages,\n            {\n                content,\n                from,\n            },\n        ];\n    }\n    /**\n     * State control methods\n     */\n    setError(error, errorType) {\n        const message = typeof error === 'string' ? error : error.message;\n        this.chatState = ChatState.Error;\n        this.error = { message, errorType };\n    }\n    reset() {\n        this.chatState = ChatState.Initial;\n        this.text = '';\n        this.error = undefined;\n        this.messages = [];\n        if (this.welcomeMessage)\n            this.appendToChat(this.welcomeMessage, MessageFrom.Bot);\n        this.audioRecorder && this.audioRecorder.clear();\n    }\n    listeningFooterJSX() {\n        const visualization = h(\"canvas\", { height: \"50\" });\n        const cancelButton = (h(\"amplify-button\", { \"data-test\": \"chatbot-cancel-button\", handleButtonClick: () => this.handleCancelButton(), class: \"icon-button\", variant: \"icon\", icon: \"ban\" }));\n        return [visualization, cancelButton];\n    }\n    footerJSX() {\n        if (this.chatState === ChatState.Listening)\n            return this.listeningFooterJSX();\n        const inputPlaceholder = this.textEnabled\n            ? Translations.TEXT_INPUT_PLACEHOLDER\n            : Translations.VOICE_INPUT_PLACEHOLDER;\n        const textInput = (h(\"amplify-input\", { placeholder: I18n.get(inputPlaceholder), description: \"text\", handleInputChange: evt => this.handleTextChange(evt), value: this.text, disabled: this.chatState === ChatState.Error || !this.textEnabled }));\n        const micButton = this.voiceEnabled && (h(\"amplify-button\", { \"data-test\": \"chatbot-mic-button\", handleButtonClick: () => this.handleMicButton(), class: \"icon-button\", variant: \"icon\", icon: \"microphone\", disabled: this.chatState === ChatState.Error ||\n                this.chatState !== ChatState.Initial }));\n        const sendButton = this.textEnabled && (h(\"amplify-button\", { \"data-test\": \"chatbot-send-button\", class: \"icon-button\", variant: \"icon\", icon: \"send\", handleButtonClick: () => this.sendTextMessage(), disabled: this.chatState === ChatState.Error ||\n                this.chatState !== ChatState.Initial }));\n        return [textInput, micButton, sendButton];\n    }\n    errorToast() {\n        if (!this.error)\n            return;\n        const { message, errorType } = this.error;\n        return (h(\"amplify-toast\", { message: I18n.get(message), handleClose: () => this.handleToastClose(errorType) }));\n    }\n    render() {\n        return (h(Host, null, h(\"div\", { class: \"amplify-chatbot\" }, h(\"slot\", { name: \"header\" }, h(\"div\", { class: \"header\", \"data-test\": \"chatbot-header\" }, I18n.get(this.botTitle))), h(\"div\", { class: \"body\", \"data-test\": \"chatbot-body\" }, this.messageJSX(this.messages)), h(\"form\", { onSubmit: e => this.handleSubmit(e) }, h(\"div\", { class: \"footer\", \"data-test\": \"chatbot-footer\" }, this.footerJSX())), this.errorToast())));\n    }\n    get element() { return getElement(this); }\n};\nAmplifyChatbot.style = amplifyChatbotCss;\n\nexport { AmplifyChatbot as amplify_chatbot };\n"]},"metadata":{},"sourceType":"module"}